"""Pydantic data models for weather trading bot"""

from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Optional, Dict, List
from pydantic import BaseModel, Field, validator


class TemperatureUnit(str, Enum):
    """Temperature units"""
    FAHRENHEIT = "F"
    CELSIUS = "C"


class MarketType(str, Enum):
    """Types of weather markets"""
    HIGH_TEMP = "high_temp"
    LOW_TEMP = "low_temp"
    PRECIPITATION = "precipitation"
    SNOW = "snow"
    UNKNOWN = "unknown"


class TradeDirection(str, Enum):
    """Trade direction"""
    BUY = "buy"
    SELL = "sell"


class TradeStatus(str, Enum):
    """Trade execution status"""
    PENDING = "pending"
    EXECUTED = "executed"
    FAILED = "failed"
    CANCELLED = "cancelled"
    UNKNOWN = "unknown"


class ConfidenceLevel(str, Enum):
    """Signal confidence levels"""
    VERY_LOW = "very_low"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    VERY_HIGH = "very_high"


class NOAAForecast(BaseModel):
    """NOAA weather forecast data"""
    city: str
    latitude: float
    longitude: float
    grid_office: str
    grid_x: int
    grid_y: int
    forecast_date: datetime
    forecast_generated_at: datetime
    
    # Temperature predictions (in Fahrenheit)
    high_temp: Optional[float] = None
    low_temp: Optional[float] = None
    high_temp_confidence: Optional[float] = None  # 0-1
    low_temp_confidence: Optional[float] = None  # 0-1
    
    # Precipitation
    precipitation_probability: Optional[float] = None  # 0-1
    
    # Metadata
    forecast_horizon_hours: int
    raw_data: Dict = Field(default_factory=dict)
    
    @validator('high_temp_confidence', 'low_temp_confidence', 'precipitation_probability')
    def validate_probability(cls, v):
        if v is not None and not 0 <= v <= 1:
            raise ValueError("Probability must be between 0 and 1")
        return v


class PolymarketMarket(BaseModel):
    """Polymarket weather market"""
    market_id: str
    condition_id: str
    question: str
    description: Optional[str] = None
    
    # Market metadata
    market_type: MarketType
    city: str
    date: datetime
    
    # Temperature thresholds (for temp markets)
    temp_threshold: Optional[float] = None
    temp_range_low: Optional[float] = None
    temp_range_high: Optional[float] = None
    temp_unit: TemperatureUnit = TemperatureUnit.FAHRENHEIT
    
    # Current market state
    yes_price: Decimal  # 0-1
    no_price: Decimal  # 0-1
    liquidity: Decimal
    volume: Decimal
    
    # Market lifecycle
    created_at: datetime
    closes_at: Optional[datetime] = None
    is_active: bool = True
    
    @validator('yes_price', 'no_price')
    def validate_price(cls, v):
        if not 0 <= v <= 1:
            raise ValueError("Market price must be between 0 and 1")
        return v
    
    @property
    def market_implied_probability(self) -> float:
        """Calculate market-implied probability for YES outcome"""
        return float(self.yes_price)


class TradingSignal(BaseModel):
    """Trading signal generated by edge detection"""
    signal_id: str
    generated_at: datetime
    
    # Market context
    market: PolymarketMarket
    noaa_forecast: NOAAForecast
    
    # Signal analysis
    direction: TradeDirection
    noaa_probability: float  # NOAA-implied probability
    market_probability: float  # Market-implied probability
    edge: float  # Difference (NOAA - Market)
    
    # Confidence & sizing
    confidence: ConfidenceLevel
    confidence_score: float  # 0-1
    recommended_position_size: Decimal
    expected_value: float
    
    # Reasoning
    reasoning: str
    risk_factors: List[str] = Field(default_factory=list)
    
    @validator('edge')
    def validate_edge(cls, v):
        if not -1 <= v <= 1:
            raise ValueError("Edge must be between -1 and 1")
        return v


class Trade(BaseModel):
    """Executed trade record"""
    trade_id: str
    signal_id: str
    executed_at: datetime
    
    # Market details
    market_id: str
    market_question: str
    direction: TradeDirection
    
    # Execution details
    position_size: Decimal
    entry_price: Decimal
    exit_price: Optional[Decimal] = None
    
    # P&L
    realized_pnl: Optional[Decimal] = None
    unrealized_pnl: Optional[Decimal] = None
    
    # Status
    status: TradeStatus
    closed_at: Optional[datetime] = None
    
    # Metadata
    notes: Optional[str] = None
    raw_response: Dict = Field(default_factory=dict)


class RiskMetrics(BaseModel):
    """Risk management metrics"""
    current_date: datetime
    
    # Position limits
    max_position_size: Decimal
    max_daily_exposure: Decimal
    current_daily_exposure: Decimal
    remaining_daily_capacity: Decimal
    
    # Active positions
    num_active_positions: int
    total_capital_at_risk: Decimal
    correlated_positions: int
    
    # Performance tracking
    total_trades: int
    winning_trades: int
    losing_trades: int
    win_rate: float
    
    # Circuit breaker
    circuit_breaker_triggered: bool
    circuit_breaker_reason: Optional[str] = None
    
    @validator('win_rate')
    def validate_win_rate(cls, v):
        if not 0 <= v <= 1:
            raise ValueError("Win rate must be between 0 and 1")
        return v


class DailyPerformance(BaseModel):
    """Daily performance summary"""
    date: datetime
    
    # Trade metrics
    num_trades: int
    winning_trades: int
    losing_trades: int
    win_rate: float
    
    # P&L
    gross_pnl: Decimal
    net_pnl: Decimal
    cumulative_pnl: Decimal
    
    # Risk
    max_drawdown: Decimal
    largest_win: Decimal
    largest_loss: Decimal
    
    # Capital
    starting_capital: Decimal
    ending_capital: Decimal
    roi: float


class BotConfig(BaseModel):
    """Bot configuration"""
    
    # NOAA settings
    noaa_update_interval_seconds: int = 3600  # 1 hour
    noaa_request_timeout_seconds: int = 15
    noaa_cache_ttl_seconds: int = 1800  # 30 minutes
    
    # Polymarket settings
    polymarket_update_interval_seconds: int = 300  # 5 minutes
    polymarket_rate_limit_per_second: float = 5.0
    
    # Signal generation
    minimum_edge_threshold: float = 0.10  # 10%
    minimum_confidence_score: float = 0.6
    minimum_liquidity: Decimal = Decimal("1000")
    
    # Risk management
    max_position_size_dollars: Decimal = Decimal("50")
    max_daily_exposure_dollars: Decimal = Decimal("500")
    stop_loss_percent: float = 0.20  # 20%
    max_correlated_positions: int = 3
    circuit_breaker_min_win_rate: float = 0.50
    circuit_breaker_lookback_trades: int = 20
    
    # Trading
    simmer_mode: str = "sandbox"  # sandbox | production
    kelly_fraction: float = 0.25  # Fractional Kelly
    
    # Monitoring
    alert_on_high_confidence_signals: bool = True
    alert_on_trade_execution: bool = True
    alert_on_large_losses: bool = True
